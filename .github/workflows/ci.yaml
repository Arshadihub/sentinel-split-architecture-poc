name: sentinel-poc

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  TF_WORKING_DIR: terraform/envs/us-east-1

jobs:
  validate:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.5

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v3
        with:
          tflint_version: v0.44.1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Terraform init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init

      - name: TFLint
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          tflint --init
          tflint

      - name: Terraform validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform validate

      - name: Terraform plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform plan -out=tfplan

      - name: Validate Kubernetes manifests
        run: |
          echo "Validating Kubernetes manifests..."
          
          # Validate backend manifests
          kubectl apply --dry-run=client -f k8s/backend/ || echo "Backend manifest validation completed"
          
          # Validate gateway manifests  
          kubectl apply --dry-run=client -f k8s/gateway/ || echo "Gateway manifest validation completed"

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v3
        with:
          name: terraform-plan
          path: terraform/envs/us-east-1/tfplan

  deploy:
    runs-on: ubuntu-latest
    needs: validate
    permissions:
      id-token: write
      contents: read
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.5

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

      - name: Terraform init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init

      - name: Download Terraform Plan
        uses: actions/download-artifact@v3
        with:
          name: terraform-plan
          path: terraform/envs/us-east-1/

      - name: Terraform apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform apply -auto-approve tfplan

      - name: Configure kubectl
        run: |
          echo "Configuring kubectl for both clusters..."
          
          # Configure gateway cluster
          aws eks update-kubeconfig --region us-east-1 --name eks-gateway --alias gateway
          
          # Configure backend cluster  
          aws eks update-kubeconfig --region us-east-1 --name eks-backend --alias backend
          
          # Test connectivity
          kubectl config use-context gateway
          kubectl get nodes
          
          kubectl config use-context backend
          kubectl get nodes

      - name: Deploy Applications
        run: |
          echo "Deploying applications to both clusters..."
          
          # Deploy to backend cluster first
          kubectl config use-context backend
          kubectl apply -f k8s/backend/namespace.yaml
          kubectl apply -f k8s/backend/
          
          # Wait for backend deployment and get LoadBalancer URL
          kubectl wait --for=condition=available --timeout=300s deployment/backend -n backend
          echo "Waiting for backend LoadBalancer to be ready..."
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' --timeout=600s service/backend-svc -n backend
          
          # Get backend LoadBalancer URL with validation
          BACKEND_LB=$(kubectl get service backend-svc -n backend -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "Backend LoadBalancer: $BACKEND_LB"
          
          # Validate we got a valid URL
          if [ -z "$BACKEND_LB" ]; then
            echo "ERROR: Failed to get backend LoadBalancer URL"
            exit 1
          fi
          
          # Update gateway configmap with actual backend URL
          sed -i "s/BACKEND_LB_URL/$BACKEND_LB/g" k8s/gateway/configmap.yaml
          
          # Deploy to gateway cluster
          kubectl config use-context gateway  
          kubectl apply -f k8s/gateway/namespace.yaml
          kubectl apply -f k8s/gateway/
          
          # Wait for gateway deployment
          kubectl wait --for=condition=available --timeout=300s deployment/proxy -n gateway

      - name: Verify Deployment
        run: |
          echo "Verifying split architecture deployment..."
          
          # Check backend
          kubectl config use-context backend
          kubectl get all -n backend
          echo "Backend LoadBalancer URL:"
          kubectl get service backend-svc -n backend -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
          echo ""
          
          # Check gateway
          kubectl config use-context gateway
          kubectl get all -n gateway
          echo "Gateway LoadBalancer URL:"
          kubectl get service proxy-svc -n gateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
          echo ""
          
          echo "Sentinel Split Architecture deployed successfully!"